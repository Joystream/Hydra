import { Service } from 'typedi';
import { getConnection } from 'typeorm';
import { BaseService, WhereInput } from 'warthog';
import { isArray, orderBy } from 'lodash';

{{#subclasses}}
import { {{className}}Service } from '../{{kebabName}}/{{kebabName}}.service'
{{/subclasses}}

import { Inject } from 'typedi';
import _ from 'lodash';
import { {{className}} } from './{{kebabName}}.model';

@Service('{{className}}Service')
export class {{className}}Service {
  constructor(
    {{#subclasses}}
     @Inject('{{className}}Service') public readonly {{camelName}}Service: {{className}}Service,
    {{/subclasses}}
  ) {}

  async find<W extends WhereInput>(where?: any, ob?: string | string[], limit?: number, offset?: number, fields?: string[]): Promise<{{className}}[]> {
    let _limit = limit || 50;
		let _offset = offset || 0;

		if (_limit + _offset > 1000) {
			throw new Error('Limit or offset are too large');
		}

		const connection = getConnection();
		const queryRunner = connection.createQueryRunner();
		// establish real database connection using our new query runner
		await queryRunner.connect();
		await queryRunner.startTransaction('REPEATABLE READ');

	{{#subclasses}}
    let  {{camelNamePlural}}: {{className}}[] = [];
    {{/subclasses}}
		try {
      // fetching all the fields to allow type-dependent field resolutions
			{{#subclasses}}
        {{camelNamePlural}} = await this.{{camelName}}Service.find(where, ob, _limit + _offset, 0);
      {{/subclasses}}
		} finally {
			await queryRunner.commitTransaction();
		}

		let collect: any[] = [{{#subclasses}}...{{camelNamePlural}}, {{/subclasses}}];
		if (ob) {
      const directions: ('asc' | 'desc')[] = []
      const attrs: string[] = []
      if (!isArray(ob)) {
        ob = [ob]
      }
      ob.map(o => {
			// NB: copied from warthog's BaseService
        const parts = o.toString().split('_');
        const direction: 'asc' | 'desc' = parts[1] as 'asc' | 'desc';
        directions.push(direction)
        attrs.push(parts[0])
      })
			collect = orderBy(collect, attrs, directions);
		}

		const _end = Math.min(collect.length, _limit + _offset);
		_offset = Math.min(collect.length, _offset);

		return collect.slice(_offset, _end);
  }
}