import { Service, Inject } from 'typedi';
import { getConnection, EntityManager } from 'typeorm';
import { WhereInput } from 'warthog';
import { isArray, orderBy } from 'lodash';

{{#subclasses}}
import { {{className}}Service } from '../{{kebabName}}/{{kebabName}}.service'
{{/subclasses}}


import { {{#subclasses}} {{className}}, {{/subclasses}} } from '../../../model';


import { {{className}} } from './{{kebabName}}.model';

import { {{className}}TypeOptions } from '../enums/enums';

@Service('{{className}}Service')
export class {{className}}Service {
  constructor(
    {{#subclasses}}
     @Inject('{{className}}Service') public readonly {{camelName}}Service: {{className}}Service,
    {{/subclasses}}
  ) {}

  async find<W extends WhereInput>(where?: any, ob?: string | string[], limit?: number, offset?: number, fields?: string[]): Promise<{{className}}[]> {
    const _limit = limit || 50;
		let _offset = offset || 0;

		if (_limit + _offset > 1000) {
			throw new Error('Limit or offset are too large');
		}

    const filteredTypes: string[] = where && where.type_in ? where.type_in : [];

		{{#subclasses}}
      let  {{camelNamePlural}}: {{className}}[] = [];
    {{/subclasses}}

    await getConnection().transaction(async (manager: EntityManager) => {
      {{#subclasses}}
        const {{camelNamePlural}}Query = this.{{camelName}}Service.getQueryBuilder(
          where,
          ob,
          _limit + _offset,
          0,
          undefined
        );
      {{/subclasses}}

      {{#interfaceRelations}}
        // relation field is requested
        {{#subclasses}}
          {{camelNamePlural}}Query.leftJoin(`{{typeormAliasName}}.{{fieldName}}`, `{{fieldName}}`);
        {{/subclasses}}
      {{/interfaceRelations}}
      
      if (filteredTypes.length) {
        {{#subclasses}}
          if (filteredTypes.includes({{interfaceEnumName}}.{{className}})) {
            {{camelNamePlural}} = await {{camelNamePlural}}Query.getMany();
          }
        {{/subclasses}}
      } else {
        {{#subclasses}}
          {{camelNamePlural}} = await {{camelNamePlural}}Query.getMany();
        {{/subclasses}}
      }
    })

		let collect: any[] = [{{#subclasses}}...{{camelNamePlural}}, {{/subclasses}}];
		if (ob) {
      const directions: ('asc' | 'desc')[] = []
      const attrs: string[] = []
      if (!isArray(ob)) {
        ob = [ob]
      }
      ob.map(o => {
			// NB: copied from warthog's BaseService
        const parts = o.toString().split('_');
        const direction: 'asc' | 'desc' = parts[1] as 'asc' | 'desc';
        directions.push(direction)
        attrs.push(parts[0])
      })
			collect = orderBy(collect, attrs, directions);
		}

		const _end = Math.min(collect.length, _limit + _offset);
		_offset = Math.min(collect.length, _offset);

		return collect.slice(_offset, _end);
  }
}