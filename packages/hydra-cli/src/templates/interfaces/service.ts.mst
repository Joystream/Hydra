import { Service, Inject } from 'typedi';
import { getConnection, EntityManager } from 'typeorm';
import { WhereInput } from 'warthog';
import { isArray, orderBy } from 'lodash';
import { GraphQLResolveInfo } from 'graphql';

{{#subclasses}}
import { {{className}}Service } from '../{{kebabName}}/{{kebabName}}.service'
{{/subclasses}}


import { {{#subclasses}} {{className}}, {{/subclasses}} } from '../../../model';


import { {{className}} } from './{{kebabName}}.model';

import { {{className}}TypeOptions } from '../enums/enums';

@Service('{{className}}Service')
export class {{className}}Service {
  constructor(
    {{#subclasses}}
     @Inject('{{className}}Service') public readonly {{camelName}}Service: {{className}}Service,
    {{/subclasses}}
  ) {}

  // TODO: Move to utils
  requestedRelations(_info: GraphQLResolveInfo) {
    const relations: { [key: string]: boolean } = {};
    [{{#interfaceRelations}}'{{fieldName}}',{{/interfaceRelations}}].map(relation => (relations[relation] = false));

    _info.fieldNodes.map(f => {
      f.selectionSet?.selections.map(s => {
        if (s.kind === 'InlineFragment') {
          s.selectionSet.selections.filter(slc => {
            if (slc.kind === 'Field') {
              const isN = relations[slc.name.value];
              if (isN !== undefined) {
                relations[slc.name.value] = true;
              }
            }
          });
        }
      });
    });
    return relations;
  }

  async find<W extends WhereInput>(
    where?: any,
    ob?: string | string[],
    limit?: number,
    offset?: number,
    fields?: string[],
    info?: GraphQLResolveInfo | string
  ): Promise<{{className}}[]> {
    const _limit = limit || 50;
		let _offset = offset || 0;

		if (_limit + _offset > 1000) {
			throw new Error('Limit or offset are too large');
		}

    const filteredTypes: string[] = where && where.type_in ? where.type_in : [];

    let requestedRelations: { [key: string]: boolean } = {};

    if (info && typeof info !== 'string') {
      const _info = info as GraphQLResolveInfo;
      requestedRelations = this.requestedRelations(_info);
    }

		{{#subclasses}}
      let  {{camelNamePlural}}: {{className}}[] = [];
    {{/subclasses}}

    await getConnection().transaction(async (manager: EntityManager) => {
      {{#subclasses}}
        const {{camelNamePlural}}Query = this.{{camelName}}Service.getQueryBuilder(
          where,
          ob,
          _limit + _offset,
          0,
          undefined
        );
      {{/subclasses}}

      {{#interfaceRelations}}
        // relation field is requested
        if (requestedRelations['{{fieldName}}']) {
          {{#subclasses}}
            {{camelNamePlural}}Query.leftJoin(`{{aliasName}}.{{fieldName}}`, `{{fieldName}}`);
          {{/subclasses}}
        }
      {{/interfaceRelations}}
      
      if (filteredTypes.length) {
        {{#subclasses}}
          if (filteredTypes.includes({{interfaceEnumName}}.{{className}})) {
            {{camelNamePlural}} = await {{camelNamePlural}}Query.getMany();
          }
        {{/subclasses}}
      } else {
        {{#subclasses}}
          {{camelNamePlural}} = await {{camelNamePlural}}Query.getMany();
        {{/subclasses}}
      }
    })

		let collect: any[] = [{{#subclasses}}...{{camelNamePlural}}, {{/subclasses}}];
		if (ob) {
      const directions: ('asc' | 'desc')[] = []
      const attrs: string[] = []
      if (!isArray(ob)) {
        ob = [ob]
      }
      ob.map(o => {
			// NB: copied from warthog's BaseService
        const parts = o.toString().split('_');
        const direction: 'asc' | 'desc' = parts[1] as 'asc' | 'desc';
        directions.push(direction)
        attrs.push(parts[0])
      })
			collect = orderBy(collect, attrs, directions);
		}

		const _end = Math.min(collect.length, _limit + _offset);
		_offset = Math.min(collect.length, _offset);

		return collect.slice(_offset, _end);
  }
}